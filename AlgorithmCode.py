# -*- coding: utf-8 -*-
"""
Previously Excursion 1 - Algorithm Code.ipynb
Now build test 1 beat generation and characteristic code for Song Processing Module
Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FhyobfLcWFhvEUFQDGCMcFz6BUMf6rXV
"""

# !!! ADJUST THESE FOR BEAT GENERATION !!!
# They're in the notebook too if you want visuals
lookaheadDivisor = 2 # How far ahead should it look for finding local maxima?
amplitudeMultiplier = 0.6 # What is the minimum threshold for local maxima?
beatCloseness = 4 # How close should the beats/local maxima be in relation to each other?

# Additionally, for easy file accessing
pathToImport = "audio.mp3" # Import as .wav or .mp3
pathToSaveAs = "generatedMap.txt"  # Export as .txt file

# To easily change while bug testing
# ATW, PTW displacement when beat timing < 1.0
atwBeforeDisplacement = 0.33333
atwAfterDisplacement = 0.66667
ptwBeforeDisplacement = 0.16667
ptwAfterDisplacement = 0.33333
beatLead = 1.0

# ATW, PTW displacement when beat timing >= 1.0
atwBeforeOne = 0.75
atwAfterOne = 1.0
ptwBeforeOne = 0.90
ptwAfterOne = 0.5
beatLeadOne = 0.0

### INITIALIZE AND PLOT AUDIO ###

# Advanced searching options with regex
import re
import sys # This is just used to send error feedback if you type the filename wrong

# Use arrays with NumPy
import numpy as np

# Getting and converting audio data
from pydub import AudioSegment, effects
import wave

# Tempo finder and DSP
import librosa
from scipy.signal import butter, lfilter, freqz

if re.search(".*mp3$", pathToImport) != None:  
  # from pydub: get audio file and convert
  sound = AudioSegment.from_mp3(pathToImport) # just put in like a 2 minute mp3 and rename this
  # normalize, as in amplify until max peak is at max volume
  sound = effects.normalize(sound)
  sound.export("converted.wav", format="wav") # convert to wav
  pathToImport = "converted.wav"

  # get the converted WAV and get sample rate
  data = wave.open("converted.wav")
  fs = data.getframerate() # sample rate
  #
elif re.search(".*wav$", pathToImport) != None:
  # get the converted WAV and get sample rate
  data = wave.open(pathToImport)
  fs = data.getframerate() # sample rate
else:
  sys.exit("ERR: Invalid import name!")


# reads all the frames; -1 indicates all or max frames
signal = data.readframes(-1)
# account for buffer so data can be plotted and used correct
signal = np.frombuffer(signal, dtype ="int32") # total time should be correct now

### MAKE SURE TOTAL TIME ADDS UP ####

### GET TEMPO ####

# we reload the wav file with librosa so the array is in a form librosa can understand
libData, libfs = librosa.load(pathToImport)
# get the tempo of the song
BPM, beats = librosa.beat.beat_track(y=libData, sr=libfs)

# BPM output is array with 1 element, we can just turn it into an int
BPM = BPM[0]

# make sure tempo is within the range of 100 to 200 BPM
goodBPM = False
while(goodBPM == False):
  if (BPM >= 100) and (BPM <= 200):
    goodBPM = True
  if BPM >= 200:
    BPM = BPM / 2
  if BPM < 100:
    BPM = BPM * 2

print('Tempo: ', BPM)

### APPLY LPF AND GRAPH ###

def makeLPF(data, cutoff, fs, order):
  b, a = butter(order, cutoff, fs=fs) # get the coefficients for the lpf
  lpf = lfilter(b, a, data) # apply filter to data
  return lpf

w0 = 100 # cutoff frequency
lpfSignal = makeLPF(signal, w0, fs, 3) # we'll keep order at 3 for now

# calculate filter coefficients outside of function
b, a = butter(3, w0, fs=fs)

### Plot the frequency response.

# h is the frequency response from 0 to 1, w is the frequency
w, h = freqz(b, a, fs=fs, worN=1500) # worN is the number of samples that are graphed

### FILTER LOCAL PEAKS INTO BINARY ARRAY ###

def filterHits(song):
  # define space for array of hits
  hitArr = np.zeros(signal.shape)
  # LPF changed maximum volume, so we'll need to grab it
  maxAmp = song.max()
  # samples per beat = samples/sec / (beats/min * 1min/60sec) = fs / (BPM/60)
  sampPerBeat = fs / (BPM / 60.0)
  lookahead = (int)(sampPerBeat)

  baseIdx, pastIdx = 0, 0 # initialize past and current index for while loop
  endOfSong = False

  # this is where we tell the the program
  while(endOfSong == False):

    # look for the local maximum within a given segment of the song
    lookaheadSegment = song[baseIdx:(baseIdx + lookahead)]
    localMax = lookaheadSegment.max()

    # find where the local maximum is
    maxIdx = baseIdx + lookaheadSegment.argmax()
    # setup the next segment to find the maximum for
    baseIdx = baseIdx + (int)(lookahead/lookaheadDivisor)

    if (localMax >= (amplitudeMultiplier * maxAmp)) and (maxIdx >= (pastIdx + (int)(fs/beatCloseness))):
      hitArr[maxIdx] = 1 # only add that maximum if it's loud enough and not too close to the last maximum

    # if there's not enough samples to have another lookahead, you've reached end of the song
    if (baseIdx >= (song.size - lookahead)):
      endOfSong = True # end the while loop

    pastIdx = maxIdx # the latest maximum index is now the previous index

  return hitArr

# call function and save to array
hitArr = filterHits(lpfSignal)

### CONVERT BINARY TO TIMING DIFFERENCE ###

## data summation for each value
def piInputCoversion(binArr, samp):
  piInArr = []
  count = 0

  for data in binArr:
    # count all of the zeros until you find something else
    if data == 0:
      count = count + 1
    # if not 0, then append the count and reset counter
    else:
      piInArr.append(count)
      #count = 0 # reset count so it's just space in between

  # if there's still a count left, append it!
  if count != 0:
    piInArr.append(count)

  # divide all of the counted zeros by the sampling frequency in order to get the time in seconds
  piInArr = [stuff/fs for stuff in piInArr]

  # convert to NumPy array
  npArr = np.array(piInArr)

  return npArr

# call function
beatMap = piInputCoversion(hitArr, fs)

# calculate time windows
atwBefore = beatMap.copy()
atwAfter = beatMap.copy()
ptwBefore = beatMap.copy()
ptwAfter = beatMap.copy()
beatLeadUp = beatMap.copy()

for index, timing in enumerate(beatMap):
  if timing <= 1.0:
    atwBefore[index] = atwBeforeOne*timing
    atwAfter[index] = atwBefore[index] + atwAfterOne
    ptwBefore[index] = ptwBeforeOne*timing
    ptwAfter[index] = ptwBefore[index] + ptwAfterOne
    beatLeadUp[index] = beatLeadOne
  elif timing > 1.0:
    atwBefore[index] = timing - atwBeforeDisplacement
    atwAfter[index] = timing + atwAfterDisplacement
    ptwBefore[index] = timing - ptwBeforeDisplacement
    ptwAfter[index] = timing + ptwAfterDisplacement
    beatLeadUp[index] = timing - beatLead

print("These are the deliverables to the board:")

print("atwBefore: ", atwBefore, "\n======================================================")
print("atwAfter: ", atwAfter, "\n======================================================")
print("ptwBefore: ", ptwBefore, "\n======================================================")
print("ptwAfter: ", ptwAfter, "\n======================================================")
print("beatLeadUp: ", beatLeadUp, "\n======================================================")  

print("Total times you hit the pads for this song:", beatMap.shape[0], "\n")

### TO DELIVER TO BOARD ###

print("Beat map: ", beatMap)
print("Sampling rate: ", fs)

# Saving the beat map to a text file
file = open("generatedMap.txt", "w+")
theStuff = str(beatMap) # copy data
file.write(theStuff) # write to file
file.close()

# Saving the first half of the atw window to a text file
file = open("atwBefore.txt", "w+")
theStuff = str(atwBefore) # copy data
file.write(theStuff) # write to file
file.close()

# Saving the second half of the atw window to a text file
file = open("atwAfter.txt", "w+")
theStuff = str(atwAfter) # copy data
file.write(theStuff) # write to file
file.close()

# Saving the first half of the ptw window to a text file
file = open("ptwBefore.txt", "w+")
theStuff = str(ptwBefore) # copy data
file.write(theStuff) # write to file
file.close()

# Saving the second half of the ptw window to a text file
file = open("ptwAfter.txt", "w+")
theStuff = str(ptwAfter) # copy data
file.write(theStuff) # write to file
file.close()

# Saving the beat lead up time to a text file
file = open("beatLeadUp.txt", "w+")
theStuff = str(beatLeadUp) # copy data
file.write(theStuff) # write to file
file.close()

print("*\n*\n*\nSuccess!")
